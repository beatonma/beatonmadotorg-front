const gulp = require("gulp");
const { dest, series, src, parallel } = gulp;

const webpack = require("webpack");
const webpackConfig = require("./webpack.config.js");

// Compilation
const sass = require("gulp-sass")(require("sass"));
const autoprefixer = require("gulp-autoprefixer");
const inline64 = require("gulp-inline-base64");

// File reduction/combination
const include = require("gulp-file-include");

// Minification/obfuscation
const cssNano = require("gulp-cssnano");

// Text processing
const find = require("gulp-find");
const replace = require("gulp-replace");

// Filesystem
const del = require("del");
const rename = require("gulp-rename");
const rsync = require("gulp-rsync");

const SRC_PATH = "src/";
const DIST_PATH = "dist/";
const BUILD_PATH = "build/";

const buildPath = path => BUILD_PATH + path;
const distPath = path => DIST_PATH + path;

const TEMP_PATH = buildPath("temp/");
const PREPROCESSING_PATH = buildPath("preprocessed/");

const srcPath = path => SRC_PATH + path;
const tempPath = path => TEMP_PATH + path;

const LOCAL_PATH = "../back/";
const FLATPAGE_TEMPLATES = [
  "base.template.html",
  "empty.template.html",
  "null.template.html",
  "about.template.html",
];

// const buildMinify = series(minifyCss, minifyHtml);
// const buildNoMinify = series(nominifyCss, minifyHtml);

const build = series(
  clean,
  buildInclude,
  parallel(buildSass, js, collectTemplates),
  parallel(minifyCss, minifyHtml, collectJs),
  parallel(buildFlatpageTemplates, buildImages, collectStatic),
  unwrap,
  cleanTemp
);

const buildDebug = series(
  clean,
  buildInclude,
  parallel(buildSass, js, collectTemplates),
  parallel(nominifyCss, minifyHtml, collectJs),
  parallel(buildFlatpageTemplates, buildImages, collectStatic),
  unwrap,
  cleanTemp
);

const localDist = () => src(DIST_PATH + "**").pipe(dest(LOCAL_PATH));
const localBuild = series(buildDebug, localDist);

function watch() {
  gulp.watch(SRC_PATH + "**/*.scss", localBuild);
  gulp.watch(SRC_PATH + "**/*.js", localBuild);
  gulp.watch(SRC_PATH + "**/*.jsx", localBuild);
  gulp.watch(SRC_PATH + "**/*.html", localBuild);
}

function buildInclude() {
  // Process @@include() tags before anything else
  return src([srcPath("**/*.js"), srcPath("**/*.jsx"), srcPath("**/*.html")])
    .pipe(include({ basepath: "@root" }))
    .on("error", log)
    .pipe(dest(PREPROCESSING_PATH));
}

function buildSass() {
  return src(SRC_PATH + "**/*.scss")
    .pipe(sass().on("error", log))
    .pipe(
      inline64({
        maxSize: 16 * 1024,
        debug: true,
        baseDir: SRC_PATH,
      }).on("error", log)
    )
    .pipe(
      rename(path => {
        path.dirname = path.dirname.replace("scss", "css");
      })
    )
    .pipe(autoprefixer().on("error", log))
    .pipe(dest(TEMP_PATH));
}

function js() {
  return new Promise((resolve, reject) => {
    webpack(webpackConfig, (err, stats) => {
      if (err) {
        return reject(err);
      }
      if (stats.hasErrors()) {
        return reject(new Error(stats.compilation.errors.join("\n")));
      }
      resolve();
    });
  });
}

function collectJs() {
  // TODO move to static dir
  return src(tempPath("**/*.js"))
    .pipe(
      rename(path => {
        // Move to apps/appname/static/appname/js
        path.dirname = path.dirname.replace(
          /apps[/\\](.+?)[/\\]js/g,
          "apps/$1/static/$1/js"
        );
        path.extname = ".min.js";
      })
    )
    .pipe(dest(DIST_PATH));
}

function minifyCss() {
  return src(tempPath("**/*.css"))
    .pipe(
      rename(path => {
        // Move to apps/appname/static/appname/css
        path.dirname = path.dirname.replace(
          /apps[/\\](.+?)[/\\]css/g,
          "apps/$1/static/$1/css"
        );
        path.extname = ".min.css";
      })
    )
    .pipe(cssNano())
    .pipe(dest(DIST_PATH));
}

function collectTemplates() {
  return src(srcPath("**/*.html")).pipe(dest(TEMP_PATH));
}

function minifyHtml() {
  return src(TEMP_PATH + "**/*.html")
    .pipe(
      replace(
        /(apps\/.*\/static\/.*)?\/?((js|css)\/.*\.(js|css))/g,
        "{% static '$2' %}"
      )
    ) // Fix filenames generated by useref in :concat and insert {% static %} tag
    .pipe(replace(/[ ]{2,}/g, "")) // Remove extra spaces
    .pipe(replace(/(\r\n){2,}/g, "\r\n")) // Remove extra line breaks
    .pipe(replace(/([%}]{1}})([\r\n]+)/g, "$1")) // Remove line breaks after django template stuff
    .pipe(dest(DIST_PATH));
}

function buildImages() {
  return src(SRC_PATH + "**/images/**/*")
    .pipe(
      rename(path => {
        // Move to apps/appname/static/appname/images
        path.dirname = path.dirname.replace(
          /apps[/\\](.+?)[/\\]images/g,
          "apps/$1/static/$1/images"
        );
      })
    )
    .pipe(dest(DIST_PATH));
}

function collectStatic() {
  return src(SRC_PATH + "static/**/*").pipe(
    dest(DIST_PATH + "main/static/main/")
  );
}

/**
 * Create a flatpage-compatible variant of each template specified in FLATPAGE_TEMPLATES.
 *
 * - Replace generic tags with flatpage-specific ones
 * - Replace 'extends' declarations with the flatpage version
 * - Rename to .flat.html extension
 * - TODO Remove dynamic tags e.g. {% if %}, {% for %}, etc.
 */
function buildFlatpageTemplates() {
  const fps = [];
  for (let x in FLATPAGE_TEMPLATES) {
    const p = TEMP_PATH + "**/templates/**/" + FLATPAGE_TEMPLATES[x];
    fps.push(p);
  }

  return src(fps)
    .pipe(
      replace(
        /(apps\/.*\/static\/.*)?\/?((js|css)\/.*\.(js|css))/g,
        "{% static '$2' %}"
      )
    ) // Fix filenames generated by useref in :concat and insert {% static %} tag
    .pipe(replace(/[ ]{2,}/g, "")) // Remove extra spaces
    .pipe(replace(/(\r\n){2,}/g, "\r\n")) // Remove extra line breaks
    .pipe(replace(/([%}]{1}})([\r\n]+)/g, "$1")) // Remove line breaks after django template stuff
    .pipe(replace(/{% block (title|header) %}.*%}/g, "{{ flatpage.title }}"))
    .pipe(replace(/{% block content %}.*%}/g, "{{ flatpage.content }}"))
    .pipe(
      replace(/{% extends '(.*?)' %}/g, match => {
        // If this template extends another, it must also be a flatpage
        // template with .flat.html extension.
        let fname = /{% extends '(.*?)' %}/g.exec(match)[1];
        fname = fname.replace(".template.html", ".flat.html");
        return "{% extends 'flatpages/" + fname + "' %}";
      })
    )
    .pipe(
      rename(path => {
        path.dirname += "/flatpages/";
        path.basename = path.basename.replace(".template", "");
        path.extname = ".flat.html";
      })
    )
    .pipe(dest(DIST_PATH));
}

async function clean() {
  return del.sync([buildPath("**/*"), DIST_PATH + "**/*"]);
}

async function cleanTemp() {
  return del.sync([
    // buildPath("**/*"),
    DIST_PATH + "/apps/",
  ]);
}

/**
 * Move everything up a directory, removing 'apps' parent directory
 */
const unwrap = () =>
  src(DIST_PATH + "/**/*")
    .pipe(
      rename(path => {
        path.dirname = path.dirname.replace(/^apps[/\\]/, "");
      })
    )
    .pipe(dest(DIST_PATH));

/**
 * Copy css files to dist directory without minification for debugging.
 */
function nominifyCss() {
  return src([SRC_PATH + "**/*.css", TEMP_PATH + "**/*.css"])
    .pipe(
      rename(path => {
        // Move to apps/appname/static/appname/css
        path.dirname = path.dirname.replace(
          /apps[/\\](.+?)[/\\]css/g,
          "apps/$1/static/$1/css"
        );
        path.extname = ".min.css";
      })
    )
    .pipe(dest(DIST_PATH));
}

function rsyncConfig(config) {
  // config must have values for `keyfile`, `username`, and `hostname`.
  return {
    options: {
      chmod: "Du=rwx,Dgo=rx,Fu=rw,Fgo=r",
      e: `ssh -i "${config.keyfile}"`,
    },
    username: config.username,
    hostname: config.hostname,
    destination: "path",
    recursive: true,
    silent: true,
    root: DIST_PATH,
    progress: false,
  };
}

// gulp.task("publish", gulp.series("build"), () =>
//   // Build and push result to PUBLIC server!
//   gulp.src(DIST_PATH + "**").pipe(
//     rsync(
//       rsyncConfig({
//         keyfile:
//           "keyfile",
//         username: "username",
//         "",
//       })
//     )
//   )
// );

// gulp.task("test", gulp.series("build"), () =>
//   // Build and push result to TEST server
//   gulp.src(DIST_PATH + "**").pipe(
//     rsync(
//       rsyncConfig({
//         keyfile:
//           "keyfile",
//         username: "username",
//         hostname: "beatonma.com",
//       })
//     )
//   )
// );

function log(err) {
  err.showStack = true;
  console.error(err);
  this.emit("end");
}

/**
 * Additional meta-tools that provide information without contributing
 * to dist output. Outputs to BUILD_PATH
 */
// gulp.task("js:find_references", () =>
const concat = require("gulp-concat");
const merge = require("merge-stream");
const jsFindReferences = () =>
  merge(
    // HTML IDs
    src([SRC_PATH + "**/*.js"]).pipe(
      find(/(querySelector\(['"]#(.*?)['"]\)|getElementById\(['"](.*?)['"]\))/g)
    ),

    // HTML classes
    src([SRC_PATH + "**/*.js"]).pipe(find(/querySelector\(['"]\.(.*?)['"]\)/g))
  )
    .pipe(concat("references.txt"))

    // Show all ID references as #name
    .pipe(replace(/getElementById\('(.*?)'\)/g, "#$1,"))
    .pipe(replace(/querySelector\('(#.*?)'\)/g, "$1,"))

    // Show all class references as .name
    .pipe(replace(/querySelector\('(\..*?)'\)/g, "$1,"))

    // Reformat to one reference per line
    .pipe(replace(/\s/g, ""))
    .pipe(replace(/,+/g, "\n"))
    .pipe(dest(BUILD_PATH));

exports.default = exports.build = build;
exports.local = localBuild;
exports.ref = jsFindReferences;
exports.watch = series(localBuild, watch);
